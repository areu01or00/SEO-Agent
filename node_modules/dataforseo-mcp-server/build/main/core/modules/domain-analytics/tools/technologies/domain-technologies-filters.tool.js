import { z } from 'zod';
import { BaseTool } from '../../../base.tool.js';
export class DomainTechnologiesFiltersTool extends BaseTool {
    client;
    static cache = null;
    static lastFetchTime = 0;
    static CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    // Map of tool names to their corresponding filter paths in the API response
    static TOOL_TO_FILTER_MAP = {
        'domain_analytics_technologies_domains_by_technology': 'domains_by_technology',
        'domain_analytics_technologies_aggregation_technologies': 'aggregation_technologies',
        'domain_analytics_technologies_technologies_summary': 'technologies_summary',
        'domain_analytics_technologies_domains_by_html_terms': 'domains_by_html_terms'
    };
    constructor(client) {
        super(client);
        this.client = client;
    }
    getName() {
        return 'domain_analytics_technologies_available_filters';
    }
    getDescription() {
        return `Here you will find all the necessary information about filters that can be used with DataForSEO Technologies API endpoints.

Please, keep in mind that filters are associated with a certain object in the result array, and should be specified accordingly.`;
    }
    supportOnlyFullResponse() {
        return true;
    }
    getParams() {
        return {
            tool: z.string().optional().describe('The name of the tool to get filters for')
        };
    }
    async fetchAndCacheFilters() {
        const now = Date.now();
        // Return cached data if it's still valid
        if (DomainTechnologiesFiltersTool.cache &&
            (now - DomainTechnologiesFiltersTool.lastFetchTime) < DomainTechnologiesFiltersTool.CACHE_TTL) {
            return DomainTechnologiesFiltersTool.cache;
        }
        // Fetch fresh data
        const response = await this.client.makeRequest('/v3/domain_analytics/technologies/available_filters', 'GET', null, true);
        this.validateResponseFull(response);
        // Transform the response into our cache format
        const filters = {};
        const result = response.tasks[0].result[0];
        // Process each tool's filters
        for (const [toolName, filterPath] of Object.entries(DomainTechnologiesFiltersTool.TOOL_TO_FILTER_MAP)) {
            const pathParts = filterPath.split('.');
            let current = result;
            // Navigate to the correct filter object
            for (const part of pathParts) {
                if (current && current[part]) {
                    current = current[part];
                }
                else {
                    current = null;
                    break;
                }
            }
            if (current) {
                filters[toolName] = current;
            }
        }
        // Update cache
        DomainTechnologiesFiltersTool.cache = filters;
        DomainTechnologiesFiltersTool.lastFetchTime = now;
        return filters;
    }
    async handle(params) {
        try {
            const filters = await this.fetchAndCacheFilters();
            if (!params.tool) {
                return this.formatResponse(filters);
            }
            const toolFilters = filters[params.tool];
            if (!toolFilters) {
                throw new Error(`No filters found for tool: ${params.tool}`);
            }
            return this.formatResponse(toolFilters);
        }
        catch (error) {
            return this.formatErrorResponse(error);
        }
    }
}
