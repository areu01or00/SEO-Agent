{"version":3,"sources":["../src/ai-chat-agent.ts"],"sourcesContent":["import type {\n  Message as ChatMessage,\n  StreamTextOnFinishCallback,\n  ToolSet,\n} from \"ai\";\nimport { appendResponseMessages } from \"ai\";\nimport { Agent, type AgentContext, type Connection, type WSMessage } from \"./\";\nimport type { IncomingMessage, OutgoingMessage } from \"./ai-types\";\n\nconst decoder = new TextDecoder();\n\n/**\n * Extension of Agent with built-in chat capabilities\n * @template Env Environment type containing bindings\n */\nexport class AIChatAgent<Env = unknown, State = unknown> extends Agent<\n  Env,\n  State\n> {\n  /**\n   * Map of message `id`s to `AbortController`s\n   * useful to propagate request cancellation signals for any external calls made by the agent\n   */\n  private _chatMessageAbortControllers: Map<string, AbortController>;\n  /** Array of chat messages for the current conversation */\n  messages: ChatMessage[];\n  constructor(ctx: AgentContext, env: Env) {\n    super(ctx, env);\n    this.sql`create table if not exists cf_ai_chat_agent_messages (\n      id text primary key,\n      message text not null,\n      created_at datetime default current_timestamp\n    )`;\n    this.messages = (\n      this.sql`select * from cf_ai_chat_agent_messages` || []\n    ).map((row) => {\n      return JSON.parse(row.message as string);\n    });\n\n    this._chatMessageAbortControllers = new Map();\n  }\n\n  private _broadcastChatMessage(message: OutgoingMessage, exclude?: string[]) {\n    this.broadcast(JSON.stringify(message), exclude);\n  }\n\n  override async onMessage(connection: Connection, message: WSMessage) {\n    if (typeof message === \"string\") {\n      let data: IncomingMessage;\n      try {\n        data = JSON.parse(message) as IncomingMessage;\n      } catch (_error) {\n        // silently ignore invalid messages for now\n        // TODO: log errors with log levels\n        return;\n      }\n      if (\n        data.type === \"cf_agent_use_chat_request\" &&\n        data.init.method === \"POST\"\n      ) {\n        const {\n          // method,\n          // keepalive,\n          // headers,\n          body, // we're reading this\n          //\n          // // these might not exist?\n          // dispatcher,\n          // duplex\n        } = data.init;\n        const { messages } = JSON.parse(body as string);\n        this._broadcastChatMessage(\n          {\n            messages,\n            type: \"cf_agent_chat_messages\",\n          },\n          [connection.id]\n        );\n        await this.persistMessages(messages, [connection.id]);\n\n        const chatMessageId = data.id;\n        const abortSignal = this._getAbortSignal(chatMessageId);\n\n        return this._tryCatchChat(async () => {\n          const response = await this.onChatMessage(\n            async ({ response }) => {\n              const finalMessages = appendResponseMessages({\n                messages,\n                responseMessages: response.messages,\n              });\n\n              await this.persistMessages(finalMessages, [connection.id]);\n              this._removeAbortController(chatMessageId);\n            },\n            abortSignal ? { abortSignal } : undefined\n          );\n\n          if (response) {\n            await this._reply(data.id, response);\n          } else {\n            // Log a warning for observability\n            console.warn(\n              `[AIChatAgent] onChatMessage returned no response for chatMessageId: ${chatMessageId}`\n            );\n            // Send a fallback message to the client\n            this._broadcastChatMessage(\n              {\n                body: \"No response was generated by the agent.\",\n                done: true,\n                id: data.id,\n                type: \"cf_agent_use_chat_response\",\n              },\n              [connection.id]\n            );\n          }\n        });\n      }\n      if (data.type === \"cf_agent_chat_clear\") {\n        this._destroyAbortControllers();\n        this.sql`delete from cf_ai_chat_agent_messages`;\n        this.messages = [];\n        this._broadcastChatMessage(\n          {\n            type: \"cf_agent_chat_clear\",\n          },\n          [connection.id]\n        );\n      } else if (data.type === \"cf_agent_chat_messages\") {\n        // replace the messages with the new ones\n        await this.persistMessages(data.messages, [connection.id]);\n      } else if (data.type === \"cf_agent_chat_request_cancel\") {\n        // propagate an abort signal for the associated request\n        this._cancelChatRequest(data.id);\n      }\n    }\n  }\n\n  override async onRequest(request: Request): Promise<Response> {\n    return this._tryCatchChat(() => {\n      const url = new URL(request.url);\n      if (url.pathname.endsWith(\"/get-messages\")) {\n        const messages = (\n          this.sql`select * from cf_ai_chat_agent_messages` || []\n        ).map((row) => {\n          return JSON.parse(row.message as string);\n        });\n        return Response.json(messages);\n      }\n      return super.onRequest(request);\n    });\n  }\n\n  private async _tryCatchChat<T>(fn: () => T | Promise<T>) {\n    try {\n      return await fn();\n    } catch (e) {\n      throw this.onError(e);\n    }\n  }\n\n  /**\n   * Handle incoming chat messages and generate a response\n   * @param onFinish Callback to be called when the response is finished\n   * @param options.signal A signal to pass to any child requests which can be used to cancel them\n   * @returns Response to send to the client or undefined\n   */\n  async onChatMessage(\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n    onFinish: StreamTextOnFinishCallback<ToolSet>,\n    // biome-ignore lint/correctness/noUnusedFunctionParameters: overridden later\n    options?: { abortSignal: AbortSignal | undefined }\n  ): Promise<Response | undefined> {\n    throw new Error(\n      \"recieved a chat message, override onChatMessage and return a Response to send to the client\"\n    );\n  }\n\n  /**\n   * Save messages on the server side and trigger AI response\n   * @param messages Chat messages to save\n   */\n  async saveMessages(messages: ChatMessage[]) {\n    await this.persistMessages(messages);\n    const response = await this.onChatMessage(async ({ response }) => {\n      const finalMessages = appendResponseMessages({\n        messages,\n        responseMessages: response.messages,\n      });\n\n      await this.persistMessages(finalMessages, []);\n    });\n    if (response) {\n      // we're just going to drain the body\n      // @ts-ignore TODO: fix this type error\n      for await (const chunk of response.body!) {\n        decoder.decode(chunk);\n      }\n      response.body?.cancel();\n    }\n  }\n\n  async persistMessages(\n    messages: ChatMessage[],\n    excludeBroadcastIds: string[] = []\n  ) {\n    this.sql`delete from cf_ai_chat_agent_messages`;\n    for (const message of messages) {\n      this.sql`insert into cf_ai_chat_agent_messages (id, message) values (${\n        message.id\n      },${JSON.stringify(message)})`;\n    }\n    this.messages = messages;\n    this._broadcastChatMessage(\n      {\n        messages: messages,\n        type: \"cf_agent_chat_messages\",\n      },\n      excludeBroadcastIds\n    );\n  }\n\n  private async _reply(id: string, response: Response) {\n    // now take chunks out from dataStreamResponse and send them to the client\n    return this._tryCatchChat(async () => {\n      // @ts-expect-error TODO: fix this type error\n      for await (const chunk of response.body!) {\n        const body = decoder.decode(chunk);\n\n        this._broadcastChatMessage({\n          body,\n          done: false,\n          id,\n          type: \"cf_agent_use_chat_response\",\n        });\n      }\n\n      this._broadcastChatMessage({\n        body: \"\",\n        done: true,\n        id,\n        type: \"cf_agent_use_chat_response\",\n      });\n    });\n  }\n\n  /**\n   * For the given message id, look up its associated AbortController\n   * If the AbortController does not exist, create and store one in memory\n   *\n   * returns the AbortSignal associated with the AbortController\n   */\n  private _getAbortSignal(id: string): AbortSignal | undefined {\n    // Defensive check, since we're coercing message types at the moment\n    if (typeof id !== \"string\") {\n      return undefined;\n    }\n\n    if (!this._chatMessageAbortControllers.has(id)) {\n      this._chatMessageAbortControllers.set(id, new AbortController());\n    }\n\n    return this._chatMessageAbortControllers.get(id)?.signal;\n  }\n\n  /**\n   * Remove an abort controller from the cache of pending message responses\n   */\n  private _removeAbortController(id: string) {\n    this._chatMessageAbortControllers.delete(id);\n  }\n\n  /**\n   * Propagate an abort signal for any requests associated with the given message id\n   */\n  private _cancelChatRequest(id: string) {\n    if (this._chatMessageAbortControllers.has(id)) {\n      const abortController = this._chatMessageAbortControllers.get(id);\n      abortController?.abort();\n    }\n  }\n\n  /**\n   * Abort all pending requests and clear the cache of AbortControllers\n   */\n  private _destroyAbortControllers() {\n    for (const controller of this._chatMessageAbortControllers.values()) {\n      controller?.abort();\n    }\n    this._chatMessageAbortControllers.clear();\n  }\n\n  /**\n   * When the DO is destroyed, cancel all pending requests\n   */\n  async destroy() {\n    this._destroyAbortControllers();\n    await super.destroy();\n  }\n}\n"],"mappings":"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","names":["response"]}